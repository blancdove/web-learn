# 原型

>原型(prototype)是 function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先，通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是对象。

```js
Person.prototype.name = "baige";
function Person(){}
var person = new Person();
console.log(person);  // {}空对象
console.elog(person.name);  // "baige"
```



### 作用

可以提取公有属性

将此构造函数所构造的对象共有的属性提取到构造函数原型上。



### constructor

>构造函数原型上隐式的属性
>
>指向对象的构造函数

```js
// Person.prototype = {
// 		constrctor: Person(){}
// }
function Person(){}
var person = new Person();
console.log(person.constructor); // function Person(){}
```



### __proto\_\_

>对象上的属性
>
>指向构造函数的原型
>
>当访问对象的属性不存在时，就会去__proto\_\_指向的原型上面去找

在用 new 来创建对象的时候，

在函数中隐式创建的 this 对象中就有一个属性就是__proto\_\_

```js
function Person(){
    // this = {}
    // return this;
}
var person = new Person();
// 其中this为
this = {
	__proto__: Person.prototype
}
```



例题

```js

1.
Person.prototype.name = "baige"; 
function Person() {
    
}
var person = new Person;
Person.prototype.name = "blancdove";
console.log(person.name) // blancdove

2.
Person.prototype.name = "baige";
function Person() {
	
}
var person = new Person;
Person.prototype = {
	name:"blancdove"
}
console.log(person.name)  // baige

3.
Person.prototype.name = "baige";
function Person() {
	
}
Person.prototype = {
	name:"blancdove"
}
var person = new Person;
console.log(person.name)  // blancdove
```





### 原型链

> 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 \_\_proto\_\_ ）指向它的构造函数的原型对象（**prototype** ）。该原型对象也有一个自己的原型对象( \_\_proto\_\_ ) ，层层向上直到一个对象的原型对象为 `null`。根据定义，`null` 没有原型，并作为这个**原型链**中的最后一个环节。

```js
// 让我们从一个函数里创建一个对象o，它自身拥有属性a和b的：
let f = function () {
   this.a = 1;
   this.b = 2;
}
/* 这么写也一样
function f() {
  this.a = 1;
  this.b = 2;
}
*/
let o = new f(); // {a: 1, b: 2}

// 在f函数的原型上定义属性
f.prototype.b = 3;
f.prototype.c = 4;

// 不要在 f 函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链
// o.[[Prototype]] 有属性 b 和 c
//  (其实就是 o.__proto__ 或者 o.constructor.prototype)
// o.[[Prototype]].[[Prototype]] 是 Object.prototype.
// 最后o.[[Prototype]].[[Prototype]].[[Prototype]]是null
// 这就是原型链的末尾，即 null，
// 根据定义，null 就是没有 [[Prototype]]。

// 综上，整个原型链如下: 

// {a:1, b:2} ---> {b:3, c:4} ---> Object.prototype---> null

console.log(o.a); // 1
// a是o的自身属性吗？是的，该属性的值为 1

console.log(o.b); // 2
// b是o的自身属性吗？是的，该属性的值为 2
// 原型上也有一个'b'属性，但是它不会被访问到。
// 这种情况被称为"属性遮蔽 (property shadowing)"

console.log(o.c); // 4
// c是o的自身属性吗？不是，那看看它的原型上有没有
// c是o.[[Prototype]]的属性吗？是的，该属性的值为 4

console.log(o.d); // undefined
// d 是 o 的自身属性吗？不是，那看看它的原型上有没有
// d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有
// o.[[Prototype]].[[Prototype]] 为 null，停止搜索
// 找不到 d 属性，返回 undefined
```



### Object.create()

可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：

```js
var a = {a: 1}; 
// a ---> Object.prototype ---> null

var b = Object.create(a);
// b ---> a ---> Object.prototype ---> null
console.log(b.a); // 1 (继承而来)

var c = Object.create(b);
// c ---> b ---> a ---> Object.prototype ---> null

var d = Object.create(null);
// d ---> null
console.log(d.hasOwnProperty); // undefined, 因为d没有继承Object.prototype
```



### call 和 apply

> 改变this指向
>
> 只有一个区别，就是 `call()` 方法接受的是**一个参数列表**，而 `apply()` 方法接受的是**一个包含多个参数的数组**。

使用 `call` 方法调用父构造函数

```js
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = 'food';
}

function Toy(name, price) {
  Product.call(this, name, price);
  this.category = 'toy';
}

var cheese = new Food('feta', 5);
var fun = new Toy('robot', 40);
```

使用 `call` 方法调用函数并且指定上下文的 '`this`'

```js
function greet() {
  var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');
  console.log(reply);
}

var obj = {
  animal: 'cats', sleepDuration: '12 and 16 hours'
};

greet.call(obj);  // cats typically sleep between 12 and 16 hours
```



用 `apply` 将数组各项添加到另一个数组

```js
var array = ['a', 'b'];
var elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // ["a", "b", 0, 1, 2]
```

































