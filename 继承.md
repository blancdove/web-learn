# 继承模式

### 传统继承-原型链

```js
var o = {
  a: 2,
  m: function(){
    return this.a + 1;
  }
};

console.log(o.m()); // 3
// 当调用 o.m 时，'this' 指向了 o.

var p = Object.create(o);
// p是一个继承自 o 的对象

p.a = 4; // 创建 p 的自身属性 'a'
console.log(p.m()); // 5
// 调用 p.m 时，'this' 指向了 p
// 又因为 p 继承了 o 的 m 函数
// 所以，此时的 'this.a' 即 p.a，就是 p 的自身属性 'a' 
```



### 借用构造函数

```js
// 定义了一些属性的Person()构造器
function Person(first, last, age, gender, interests) {
  this.name = {
    first,
    last
  };
  this.age = age;
  this.gender = gender;
  this.interests = interests;
};
// 所有的方法都定义在构造器的原型上
Person.prototype.greeting = function() {
  alert('Hi! I\'m ' + this.name.first + '.');
};

function Teacher(first, last, age, gender, interests, subject) {
  Person.call(this, first, last, age, gender, interests);

  this.subject = subject;
}
```



### 公有原型

```js
Father.prototype.lastName = 'chen';
function Father(){

}
function Son(){

}
Function.prototype = Son.prototype;
var father = new Father();
var son = new Son();
```





### 圣杯模式

```js
Father.prototype.lastName = "chen";
// Father.prototype = {
// 	lastName: 'chen'
// }
function Father() {}
function Son() {}

// 普通继承写法
function inherit(target, origin) {
    function F() {}
    F.prototype = origin.prototype;
    target.prototype = new F();
    target.prototype.constructor = target;
    target.prototype.uber = origin.prototype;
}

// 雅虎YUI3继承写法
var inherit = (function () {
    var F = function () {};
    return function (target, origin) {
        F.prototype = origin.prototype;
        target.prototype = new F();
        target.prototype.constructor = target;
        target.prototype.uber = origin.prototype;
    };
}());


inherit(Son, Father);

var son = new Son();
var father = new Father();
```





























