# 继承模式

### 传统继承-原型链

```js
var o = {
  a: 2,
  m: function(){
    return this.a + 1;
  }
};

console.log(o.m()); // 3
// 当调用 o.m 时，'this' 指向了 o.

var p = Object.create(o);
// p是一个继承自 o 的对象

p.a = 4; // 创建 p 的自身属性 'a'
console.log(p.m()); // 5
// 调用 p.m 时，'this' 指向了 p
// 又因为 p 继承了 o 的 m 函数
// 所以，此时的 'this.a' 即 p.a，就是 p 的自身属性 'a' 
```



### 借用构造函数

```js
// 定义了一些属性的Person()构造器
function Person(first, last, age, gender, interests) {
  this.name = {
    first,
    last
  };
  this.age = age;
  this.gender = gender;
  this.interests = interests;
};
// 所有的方法都定义在构造器的原型上
Person.prototype.greeting = function() {
  alert('Hi! I\'m ' + this.name.first + '.');
};

function Teacher(first, last, age, gender, interests, subject) {
  Person.call(this, first, last, age, gender, interests);

  this.subject = subject;
}
```



### 圣杯模式

```js
Father.prototype = {
    name:"baige"
};

function Father() {

}

function F(){};  // 定义一个构造函数 F  
F.prototype = Father.prototype;  // 将原型共享；
Son.prototype = new F();  // 

function Son() {

}
Son.prototype.age = 18
var son = new Son();
var father = new Father()
```





















































