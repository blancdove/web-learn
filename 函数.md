

# 函数

#### 函数声明

function fn(){

}



### 函数表达式

**命名函数表达式**

var test = function abc(){

}

命名函数表达式的变量名会替代函数名的作用，意思就是调用函数必须 test()才可以，假如执行 abc() 就会报错，这个 abc 就不起作用了，但是输出 test.name 会得到 abc

**匿名函数表达式**

既然命名函数表达式的函数名不起作用了，所以就可以省略了。

var test = function (){

}

输出 test.name 会得到 test。



#### 函数参数

**实参列表arguments**

如果实参和形参数量相等，那么形参和argments之间有种映射关系，形参变量值改变对应位置的arguments[i]也随之改变，反之亦然。

如果实参比形参少，那么多余的形参和argments之间就没有了映射关系，即多余形参值得改变，对应位置的arguments[i]的值仍为undefined，反之亦然。

```js
1.
var compare =  function(a, b) {
	if(arguments.length < compare.length) {
		console.log("实参小于形参数")；
		//compare.length 形参长度
		//arguments.length  实参列表长度
	}
};
compare(1);
2.
var compare =  function(a, b) {
	var b = 2;
	console.log(arguments[1]);
	//b是undefined
};
compare(1);
3.
var compare =  function(a, b) {
	var b = 3;
	console.log(arguments[1]);
	//b是3
};
compare(1, 2);
```



### 预编译

> 函数的预编译发生在函数执行的前一刻，全局的发生在全局执行的前一刻



**imply global 暗示全局变量**

即任何变量，如果变量未经声明就赋值，此变量就为全局变量所有。



**声明全局变量**

一切声明的全局变量，全是 window 属性。





**函数预编译四部曲**

1. 创建AO对象
2. 找形参和变量声明作为AO对象的属性名，值为undefined
3. 实参值和形参相统一
4. 找函数声明的函数名作为AO对象的属性名，值为函数体



**全局预编译**

1. 创建GO对象（Global Object全局的执行期上下文）
2. 找变量声明作为GO的属性名，值为undefined
3. 找函数声明的函数名作为AO对象的属性名，值为函数体



### 作用域

**执行期上下文（就是上面的 AO）**

当函数执行的前一刻，会创建一个称为执行期上下文的内部对象，一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，**当函数执行完毕，他创建的执行期上下文被销毁**



**[[scope]]**

每个 JavaScript 函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供 JavaScript 引擎存取，[[scope]]就是其中一个，[[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。



**作用域链**

[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。在哪个函数里边查找变量，就去哪个函数的作用域链顶端依次向下查找。



### 闭包

```js
function test1(){
	var a = 1;
    return function(){
        console.log(a) // 1
    }
}
var test2 = test1();
test2();
```

**闭包的产生**

但凡内部函数被保存到了外部，它一定生成闭包。



**闭包的现象**

当内部函数被保存到外部时，就会生成闭包，闭包会导致原有作用域链不释放，造成内存泄露。



#### 闭包的应用

**累加器**

```js
function add(){
    var count = 0;
    function demo(){
        count++;
        console.log(count);
    }
    return demo;
}
var counter = add();
counter();  // 1
counter();  // 2
```



**缓存（存储结构）**

```js
function test(){
    var num = 100;
    function a(){
        num++;
        console.log(num);
    }
    function b(){
        num--;
        console.log(num);
    }
    return [a,b]
}
var myArr = test();
myArr[0]();  // 101
myArr[1]();  // 100
```



**属性私有化**

```js
function Cheater(name, wife){
    var prepareWife = "goddess";  // 私有化变量
    this.name = name;
    this.wife = wife;
    this.sayPrepareWife = function(){ // 闭包
        console.log(prepareWife);
    };
    this.divorce = function(){
        this.wife = prepareWife;
    }
}
var cheater = new Cheater('xiaozhu','xiaoliu')
```



**模块化开发，防止污染全局变量**

```js
var name = "global";

var initBaiGe = (function(){
    var name = "baige";
    function sayName(){
        console.log(name);
    }
    return function(){
        sayName();
    }
}());

var initBlancDove = (function(){
    var name = "blancdove";
    function sayName(){
        console.log(sayName);
    };
    return function(){
        sayName();
    }
}());
```



### 立即执行函数

> 执行完毕后立即销毁

**写法**

```js
1. 
(function (){ }())	W3C推荐使用
2. 
(function (){ })()
```

**接收参数**

```js
(function (a,b){
	console.log(a + b); // 3
}(1,2))
```

**扩展**

只有表达式才能被执行符号()执行。

```js
function test(){
    console.log(1)
}()
// 报错，因为这里为函数声明，而不是函数表达式。
```



能被执行符号执行的表达式他的函数名就会被自动放弃，即能被执行符号执行的表达式就变成了立即执行函数

```js
1.
var test = function (){
	console.log(1);
}()
// 此时可以执行，这里为函数表达式。
2.
+function test(){
	console.log(1);
}()
// 本来他是函数声明，但是在前边加上正号他就理论上转换为数字了，那他就是一个表达式，在后边直接加()就会执行，变成立即执行函数，然后忽略函数名，执行完后输出 test 就会报错，
// 前边加上-或者!都可以，&&和||也可以，不过两边都要有东西，但是*和/不行，这里的+-代表正负号
```

例题

```js
var f = (
    function f() {
        return "1";
    },
    function g() {
        return 2;
    }
)();
console.log(typeof f);  // "number"
// 逗号操作符，逗号也可以当操作符用，但是两边必须加上括号，返回后边表达式的值，
// var a =（1,2），那么 a 的值为 2
// 所以题中 f 等于 g 函数的返回值，输出得 number
```





**解决闭包引发的问题**

问题

```js
function test(){
    var arr =[];
    for(var i = 0; i < 10; i++){
		arr[i] = function(){ // 给arr中添加10个函数
            console.log(i)
        }
    }
    return arr;
}
var myArr = test();
for(var j = 0; j < 10; j++){
	myArr[j]();
}
// 预期输出0 1 2 3 4 5 6 7 8 9
// 实际输出10 10 10 10 10 10 10 10 10 10
```

原因

每个数组中的函数都使用的同一个变量i，在循环结束后，i的值为10



解决

```js
function test(){
    var arr =[];
    for(var i = 0; i < 10; i++){
        (function(j){
			arr[j] = function(){ 
            	console.log(j)
        	}
        }(i)) // 利用立即执行函数将i的值保存到了函数里面
    }
    return arr;
}
var myArr = test();
for(var n = 0; n < 10; n++){
	myArr[n]();
}
```



### 构造函数

>经过new关键字的函数
>
>在函数最前面隐式的创建一个this对象
>
>在最后隐式的返回this对象

```js
function Person(name,age){
	// var this = {};
    
    this.name = name;
    this.age = age;
    
    // return this
}
var person = new Person();
```

假如手动返回一个空对象

```js
function Person(name,age){
	// var this = {};
    
    this.name = name;
    this.age = age;
    return {};  // 手动返回一个空对象
    // return 123;  // 返回原始值无效
    
    // return this;
}
var person = new Person();
```

得到的person就会是一个空对象。

系统内部只支持返回引用值，假如手动返回原始值会无效。



### 包装类

> 对象能添加属性和方法，但是原始值不能添加属性和方法。

但是原始值调用属性和方法时并不会报错（undefined，null除外）
原因是原始值调用属性和方法时会经历包装类。

- Number
- String
- Boolean

首先需要知道

```js
var num = new Number(123)

num.a = "a"
// 数字123在经过new关键字后，num是一个对象，是对象就可以添加属性和方法。
num*2
// 但是依然可以参与运算
```

原因

```js
var num = 123
num.abc = "abc"; // 隐式new Number(num).abc = "abc"; 然后销毁
console.log(num.abc)  // 当访问的时候，同样隐式new Number(num).abc; 访问的abc属性没有
// 输出undefined
```

例题

```js
var str = 'baige';
str.length = 3; // new String(str).length = 3; 然后销毁
console.log(str)  // 'baige'
```



























